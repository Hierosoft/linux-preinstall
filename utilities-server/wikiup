#!/usr/bin/env python3
"""wikiup - Upgrade MediaWiki by moving images and LocalSettings.php.

This script migrates a MediaWiki installation from one version to another by
moving user-uploaded images, copying LocalSettings.php, .htaccess, copying
missing extensions and skins, setting permissions, and updating the public
symlink (public_html or $WWW_DIR).

Usage:
    wikiup <src> <dst> [--dry-run] [--skip-permissions]

When --dry-run is used, the script outputs a bash-compatible script to stdout.
Otherwise, it performs the actions and prints progress to stderr via logger.
"""

import argparse
import logging
import os
import shutil
import sys
from pathlib import Path


class WikiUpError(RuntimeError):
    """Raised for expected operational failures during upgrade.

    Attributes:
        exit_code: Exit code to return to the shell.
    """

    def __init__(self, message, exit_code=1):
        """Initialize with message and exit code."""
        super().__init__(message)
        self.exit_code = exit_code


def get_logger():
    """Return a logger named after the script filename.

    Returns:
        logging.Logger: Configured logger instance.
    """
    script_name = os.path.basename(sys.argv[0])
    name = os.path.splitext(script_name)[0]
    return logging.getLogger(name)


def echo0(*args, **kwargs):
    """Print to stderr without INFO prefix.

    Args:
        *args: Positional arguments for print().
        **kwargs: Keyword arguments for print().

    Returns:
        bool: Always True.
    """
    kwargs['file'] = sys.stderr
    print(*args, **kwargs)
    return True


# Shell quoting: only quote if necessary
BAD_CHARS = {
    'Linux': ' \t\n\r\'"\\$`<>|;&()#*?[]{}!',
    'Darwin': ' \t\n\r\'"\\$`<>|;&()#*?[]{}!',
    'Windows': ' \t\n\r"%^&|<>',
}

def _q(path):
    """Return shell-quoted path only if it contains unsafe characters.

    Args:
        path: Path to quote.

    Returns:
        str: Quoted path if needed, otherwise raw.
    """
    path_str = str(path)
    platform = sys.platform
    if platform.startswith('win'):
        bad = BAD_CHARS['Windows']
    else:
        bad = BAD_CHARS.get('Linux', '')  # fallback
    if any(c in bad for c in path_str):
        # Escape single quotes by closing, inserting \', reopening
        return "'" + path_str.replace("'", "'\\''") + "'"
    return path_str


def _print_undo(undo_commands):
    """Print undo commands as comments and commands."""
    echo0("# undo partial upgrade:")
    for cmd in undo_commands:
        if cmd:
            echo0(cmd)


def _copy_config_file(src_file, dst_file, dst_backup, dry_run, out, logger, undo_list):
    """Copy a config file with backup logic.

    Args:
        src_file: Source file path.
        dst_file: Destination file path.
        dst_backup: Backup file path (e.g. LocalSettings.php.1st).
        dry_run: Whether to simulate.
        out: Output stream (for dry-run).
        logger: Logger instance.
        undo_list: List to append undo commands.

    Raises:
        WikiUpError: If backup exists.
    """
    if dst_file.exists():
        if dst_backup.exists():
            logger.error("Backup already exists: %s", dst_backup)
            _print_undo([f"mv {_q(dst_backup)} {_q(dst_file)}"])
            raise WikiUpError("Config backup exists", 5)
        else:
            cmd = f"cp -a {_q(dst_file)} {_q(dst_backup)}"
            undo = f"mv {_q(dst_backup)} {_q(dst_file)}"
            if dry_run:
                print(cmd, file=out)
            else:
                logger.info("Backing up %s to %s", dst_file.name, dst_backup.name)
                shutil.copy2(str(dst_file), str(dst_backup))
                undo_list.append(undo)
    # If dst_file does not exist, skip backup

    if src_file.exists():
        cmd = f"cp -a {_q(src_file)} {_q(dst_file)}"
        undo = f"rm -f {_q(dst_file)}"
        if dst_file.exists():
            undo = f"mv {_q(dst_backup)} {_q(dst_file)}"
        if dry_run:
            print(cmd, file=out)
        else:
            logger.info("Copying %s to new version", src_file.name)
            shutil.copy2(str(src_file), str(dst_file))
            undo_list.append(undo)
    else:
        logger.warning("No %s found to copy", src_file)


def _set_permissions(target_dir, dry_run, out, logger):
    """Set standard MediaWiki permissions on PHP files and directories.

    Args:
        target_dir: Directory to set permissions on (should be www_dir symlink).
        dry_run: Whether to simulate.
        out: Output stream (for dry-run).
        logger: Logger instance.
    """
    if dry_run:
        print(f"# Setting permissions in {_q(target_dir)}", file=out)
        print(f"chmod 644 {_q(target_dir / 'index.php')} {_q(target_dir / 'api.php')}", file=out)
        print(f"find {_q(target_dir)} -type f -name \"*.php\" -exec chmod 644 {{}} \\;", file=out)
        print(f"find {_q(target_dir)} -type d -exec chmod 755 {{}} \\;", file=out)
    else:
        logger.info("Setting permissions in %s", target_dir)

        # Explicitly set index.php and api.php
        for entry in ["index.php", "api.php"]:
            path = target_dir / entry
            if path.exists():
                try:
                    path.chmod(0o644)
                except Exception as e:
                    logger.error("Failed to chmod %s: %s", path, e)
                    echo0("# Failed to chmod %s" % path)
                    echo0(f"chmod 644 {_q(path)}")

        # Set permissions on all PHP files
        for php_file in target_dir.rglob("*.php"):
            try:
                php_file.chmod(0o644)
            except Exception as e:
                logger.error("Failed to chmod PHP file %s: %s", php_file, e)
                echo0("# Failed to chmod %s" % php_file)
                echo0(f"chmod 644 {_q(php_file)}")

        # Set permissions on all directories
        for dir_path in target_dir.rglob("*"):
            if dir_path.is_dir():
                try:
                    dir_path.chmod(0o755)
                except Exception as e:
                    logger.error("Failed to chmod directory %s: %s", dir_path, e)
                    echo0("# Failed to chmod %s" % dir_path)
                    echo0(f"chmod 755 {_q(dir_path)}")


def _handle_component(src_dir, dst_dir, name, dry_run, out, logger, undo_list):
    """Handle copying missing extensions or skins.

    Args:
        src_dir: Source directory (e.g. src/extensions).
        dst_dir: Destination directory (e.g. dst/extensions).
        name: Component name ("extensions" or "skins").
        dry_run: Whether to simulate.
        out: Output stream (for dry-run).
        logger: Logger instance.
        undo_list: List to append undo commands.

    Returns:
        Tuple of (total_count, new_count).
    """
    total_count = 0
    new_count = 0

    if not src_dir.exists():
        logger.warning("No %s", src_dir)
        return total_count, new_count

    if not dst_dir.exists():
        cmd = f"mkdir -p {_q(dst_dir)}"
        undo = f"rmdir {_q(dst_dir)} 2>/dev/null || true"
        if dry_run:
            print(cmd, file=out)
        else:
            logger.info("Creating %s directory: %s", name, dst_dir)
            dst_dir.mkdir(parents=True, exist_ok=True)
            undo_list.append(undo)

    for item in src_dir.iterdir():
        if item.is_dir():
            total_count += 1
            dst_sub = dst_dir / item.name
            if not dst_sub.exists():
                cmd = f"rsync -a {_q(item)}/ {_q(dst_sub)}/"
                undo = f"rm -rf {_q(dst_sub)}"
                if dry_run:
                    print(cmd, file=out)
                    new_count += 1
                else:
                    try:
                        logger.info("Copying %s: %s", name[:-1], item.name)
                        shutil.copytree(str(item), str(dst_sub))
                        new_count += 1
                        undo_list.append(undo)
                    except Exception as e:
                        logger.error(
                            "Failed to copy %s %s: %s", name[:-1], item.name, e
                        )

    return total_count, new_count


def perform_wiki_upgrade(src, dst, www_dir, dry_run=False, skip_permissions=False):
    """Perform the MediaWiki upgrade from src to dst.

    Args:
        src: Path to current MediaWiki installation.
        dst: Path to new MediaWiki installation.
        www_dir: Path to public symlink (public_html or $WWW_DIR).
        dry_run: If True, output bash script instead of modifying filesystem.
        skip_permissions: If True, skip setting file permissions.

    Raises:
        WikiUpError: On validation or operational failure.
    """
    logger = get_logger()
    out = sys.stdout if dry_run else None
    undo_commands = []

    def log(msg):
        """Log to stderr or stdout with # prefix in dry-run."""
        if dry_run:
            print(f"# {msg}", file=out)
        else:
            logger.info("%s", msg)

    # Validate source and destination
    if not src.is_dir():
        logger.error("Source directory does not exist or is not a directory: %s", src)
        _print_undo([])
        raise WikiUpError("Invalid source directory", 1)
    if not dst.is_dir():
        logger.error("Destination directory does not exist or is not a directory: %s", dst)
        _print_undo([])
        raise WikiUpError("Invalid destination directory", 1)

    # Validate WWW_DIR symlink
    if www_dir.exists() and not www_dir.is_symlink():
        logger.error(
            "%s exists but is not a symlink. This script assumes it is "
            "the symlink to the latest version. Set WWW_DIR to a different "
            "path or remove/rename the existing %s.", www_dir, www_dir
        )
        _print_undo([])
        raise WikiUpError("WWW_DIR not a symlink", 1)

    src_images = src / "images"
    dst_images = dst / "images"
    dst_images_1st = dst / "images.1st"

    if not src_images.is_dir():
        undo = []
        if dst_images.exists():
            undo.append(f"mv {_q(dst_images)} {_q(src_images)}")
        if dst_images_1st.exists():
            undo.append(f"mv {_q(dst_images_1st)} {_q(dst_images)}")
        logger.error("Already moved: %s", src_images)
        _print_undo(undo)
        raise WikiUpError("Images already moved", 2)

    if dst_images.is_dir():
        if dst_images_1st.exists():
            logger.error("Already backed up stock images: %s", dst_images_1st)
            _print_undo([f"mv {_q(dst_images_1st)} {_q(dst_images)}"])
            raise WikiUpError("Stock images already backed up", 3)
        else:
            cmd = f"mv {_q(dst_images)} {_q(dst_images_1st)}"
            undo = f"mv {_q(dst_images_1st)} {_q(dst_images)}"
            if dry_run:
                print(cmd, file=out)
            else:
                log("Moving stock images: %s to %s" % (dst_images, dst_images_1st))
                shutil.move(str(dst_images), str(dst_images_1st))
                undo_commands.append(undo)
    else:
        logger.error("No stock images directory: %s", dst_images)
        _print_undo([])
        raise WikiUpError("No stock images", 4)

    # Move user images
    cmd = f"mv {_q(src_images)} {_q(dst)}/"
    undo = f"mv {_q(dst / 'images')} {_q(src_images)}"
    if dry_run:
        print(cmd, file=out)
    else:
        log("Moving user images: %s to %s/" % (src_images, dst))
        shutil.move(str(src_images), str(dst))
        undo_commands.append(undo)

    # Copy .htaccess
    _copy_config_file(
        src / ".htaccess",
        dst / ".htaccess",
        dst / ".htaccess.1st",
        dry_run,
        out,
        logger,
        undo_commands,
    )

    # Copy LocalSettings.php
    _copy_config_file(
        src / "LocalSettings.php",
        dst / "LocalSettings.php",
        dst / "LocalSettings.php.1st",
        dry_run,
        out,
        logger,
        undo_commands,
    )

    # === EXTENSIONS HANDLING ===
    if dry_run:
        print("# Checking extensions...", file=out)
    else:
        log("Checking extensions...")
    ext_total, ext_new = _handle_component(
        src / "extensions",
        dst / "extensions",
        "extensions",
        dry_run,
        out,
        logger,
        undo_commands,
    )
    if dry_run:
        print("# Processed %d, would copy %d new." % (ext_total, ext_new), file=out)
    else:
        log("Processed %d, copied %d new." % (ext_total, ext_new))

    # === SKINS HANDLING ===
    if dry_run:
        print("# Checking skins...", file=out)
    else:
        log("Checking skins...")
    skin_total, skin_new = _handle_component(
        src / "skins",
        dst / "skins",
        "skins",
        dry_run,
        out,
        logger,
        undo_commands,
    )
    if dry_run:
        print("# Processed %d, would copy %d new." % (skin_total, skin_new), file=out)
    else:
        log("Processed %d, copied %d new." % (skin_total, skin_new))

    # Update symlink
    old_link = None
    if www_dir.exists():
        try:
            old_link = www_dir.readlink()
        except Exception:
            pass
        cmd = f"rm -f {_q(www_dir)}"
        undo = f"ln -s {_q(old_link)} {_q(www_dir)}" if old_link else ""
        if dry_run:
            print(cmd, file=out)
        else:
            log("Removing existing symlink: %s" % www_dir)
            try:
                www_dir.unlink()
                if undo:
                    undo_commands.append(undo)
            except OSError as e:
                logger.error("Failed to remove %s: %s", www_dir, e)
                _print_undo(undo_commands[::-1])
                raise WikiUpError("Failed to remove symlink", 7)

    cmd = f"ln -s {_q(dst)} {_q(www_dir)}"
    undo = f"rm -f {_q(www_dir)} && ln -s {_q(old_link)} {_q(www_dir)}" if old_link else f"rm -f {_q(www_dir)}"
    if dry_run:
        print(cmd, file=out)
    else:
        log("Creating symlink: %s to %s" % (www_dir, dst))
        try:
            www_dir.symlink_to(dst)
            undo_commands.append(undo)
        except OSError as e:
            logger.error("Failed to create symlink %s to %s: %s", www_dir, dst, e)
            _print_undo(undo_commands[::-1])
            raise WikiUpError("Failed to create symlink", 7)

    # Set permissions on the live site (via symlink)
    if not skip_permissions:
        if not dry_run:
            if not www_dir.resolve().samefile(dst):
                logger.warning("Symlink %s does not point to %s â€” skipping permissions", www_dir, dst)
            else:
                _set_permissions(www_dir, dry_run, out, logger)
        else:
            _set_permissions(www_dir, dry_run, out, logger)

    # Final instructions
    instructions = [
        "",
        "# If you have set a custom $wgUploadDirectory (default is false),",
        "# you must move it from %s to %s manually now." % (src, dst),
        "#",
        "# After you have transferred any custom upload directory",
        "# ($wgUploadDirectory), deleted file archives, and any custom skins,",
        "# run the database upgrade script with the correct PHP version:",
        "#",
        "#   php %s/maintenance/update.php" % _q(www_dir),
        "#",
        "# Extensions and skins usually need to be upgraded at the same time as the MediaWiki core.",
    ]
    for line in instructions:
        if dry_run:
            print(line, file=out)
        else:
            echo0(line.lstrip("# ").strip() or "")

    if dry_run:
        print("\n# [DRY RUN] Script generated successfully.", file=out)


def main():
    """Parse arguments and run upgrade."""
    # Configure logger
    logger = get_logger()
    handler = logging.StreamHandler(sys.stderr)
    formatter = logging.Formatter("%(levelname)s: %(message)s")
    handler.setFormatter(formatter)
    logger.addHandler(handler)
    logger.setLevel(logging.INFO)

    parser = argparse.ArgumentParser(
        description=(
            "Upgrade MediaWiki by moving images and LocalSettings.php from "
            "source to destination, and updating the WWW_DIR symlink."
        ),
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument("src", help="Source MediaWiki directory (current version)")
    parser.add_argument("dst", help="Destination MediaWiki directory (new version)")
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Output bash script to stdout instead of performing actions",
    )
    parser.add_argument(
        "--skip-permissions",
        action="store_true",
        help="Skip setting file/directory permissions",
    )

    args = parser.parse_args()

    # Resolve src and dst as given (do not resolve to target if symlink)
    src = Path(args.src)
    dst = Path(args.dst)

    # WWW_DIR is relative to current working directory unless absolute
    www_dir_str = os.getenv("WWW_DIR", "public_html")
    www_dir = Path(www_dir_str)
    if not www_dir.is_absolute():
        www_dir = Path.cwd() / www_dir

    if args.dry_run:
        print("#!/bin/bash")
        print("# Generated by wikiup --dry-run")
        print("# Run this script to perform the upgrade")
        print()

    try:
        perform_wiki_upgrade(
            src,
            dst,
            www_dir,
            dry_run=args.dry_run,
            skip_permissions=args.skip_permissions,
        )
        return 0
    except WikiUpError as e:
        logger.error("%s", e)
        return e.exit_code


if __name__ == "__main__":
    sys.exit(main())
